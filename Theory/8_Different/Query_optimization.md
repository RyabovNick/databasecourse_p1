https://docs.oracle.com/cd/E11882_01/server.112/e41573/optimops.htm#PFGRF94582

# Оптимизатор запросов

СУБД может запускать SQL запросы разными путями - полное сканирование таблицы, с индексами, вложенными циклами и hash join.

Когда пользователь отправляет запрос, оптимизатор выполняет следующие шаги:

1. Генерирует набор потенциальных планов для SQL запроса на основе путей доступа.
2. Оценивает стоимость каждого плана на основе статистики в словаре данных. Статистика включает в себя информацию о распределении, хранении таблиц, индексов, партиций к которым обращается оператор.

   **Стоимость** - это расчётное значение, пропорциональное ожидаемому использованию ресурсов, необходимому для выполнения запроса с конкретным планом. Вычисления производятся также с учётом вычислительных мощностей компьютера.

3. Оптимизатор сравнивает планы и выбирает план с наименьшими затратами.

## View merging

## Predicate pushing

## Subquery Unnesting

Оптимизатор запросов преобразует вложенные запросы в эквивалент с соединением таблиц.

Например, мы хотим вывести всех студентов, которые занимаются в данный момент каким-либо хобби

Вариант с вложенностью.

```sql
SELECT *
FROM students
WHERE id IN
    (SELECT id
     FROM students_hobbies
     WHERE date_finish IS NULL)
```

Да, оптимизатор запросов преобразует это в соединение таблиц через JOIN.

**Используйте в подобных запросах сразу синтаксис с соединением таблиц!**

```sql
SELECT students.*
FROM students, stud_hobby
WHERE students.id = stud_hobby.id and stud_hobby.date_finish is null
```

Именно в такой вид будет преобразован запрос выше. Но используйте сразу его. Обязательно!

Или соединение таблиц при помощи INNER JOIN..

## Query Rewrite with Materialized Views
